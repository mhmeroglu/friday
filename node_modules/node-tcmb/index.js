const _ = require("lodash");
const moment = require("moment");
const request = require("request");
const iconv = require("iconv-lite");
const parseString = require("xml2js").parseString;

const validCurrencies = [
  "USD",
  "AUD",
  "DKK",
  "EUR",
  "GBP",
  "CHF",
  "SEK",
  "CAD",
  "KWD",
  "NOK",
  "SAR",
  "JPY",
  "BGN",
  "RON",
  "RUB",
  "IRR",
  "CNY",
  "PKR",
  "QAR",
  "XDR",
];

const infoCurrencies = [
  "ARS",
  "ALL",
  "AZN",
  "BHD",
  "BDT",
  "AED",
  "BAM",
  "BWP",
  "BRL",
  "DZD",
  "CZK",
  "IDR",
  "MAD",
  "PHP",
  "ZAR",
  "KRW",
  "GEL",
  "INR",
  "HRK",
  "HKD",
  "IQD",
  "ISK",
  "KZT",
  "LYD",
  "HUF",
  "MKD",
  "MYR",
  "MXN",
  "EGP",
  "NAD",
  "UZS",
  "PEN",
  "PLN",
  "RSD",
  "SGD",
  "SDG",
  "SYP",
  "SZL",
  "THB",
  "TND",
  "TMT",
  "UAH",
  "OMR",
  "JOD",
  "VND",
  "ILS",
  "TWD",
  "NZD",
];

module.exports = {
  rates: {
    today: (currency) => preparePromise(null, currency),
    date: (date, currency) => preparePromise(date, currency),
  },
};

/**
 * Reduces the given date by 1
 *
 * @param {*} date DD/MM/YYYY
 * @returns {string}
 */
function decreaseDay(date) {
  let momentDate = moment(date, "DD/MM/YYYY");
  return momentDate.subtract(1, "d").format("DD/MM/YYYY").toString();
}

/**
 * This function makes a request to TCMB service to retrieve parity of specified date.
 *
 * @param {*} date
 * @param {*} currency
 * @returns {*}
 */
const preparePromise = (date, currency) => {
  return new Promise(async (resolve, reject) => {
    try {
      let type = "valid";
      if (currency && currency.trim() !== "") {
        currency = currency.trim().toUpperCase();
        if (_.includes(validCurrencies, currency)) {
          type = "valid";
        } else if (_.includes(infoCurrencies, currency)) {
          type = "info";
        } else {
          return reject(
            new Error(`Provided currency ${currency} is not supported!`)
          );
        }
      }
      let url = prepareURL(type, date);
      if (!url)
        return reject(
          new Error("Something went wrong while preparing request URL.")
        );
      const response = await holidayCheck(type, date, 20);
      if (response) {
        let xml = iconv.decode(response, "UTF-8");
        if (!xml || xml.search("Tarih_Date") === -1) {
          return reject(new Error("Invalid xml"));
        }
        let data = await parseXML(xml);
        let result = convertData(data, currency, type);
        if (!result) return reject(new Error("Something went wrong!"));
        return resolve(result);
      } else {
        return reject(response);
      }
    } catch (error) {
      return reject(error);
    }
  });
};

/**
 * Returns proper URL according to provided date.
 * @param {*} date DD/MM/YYYY
 * @returns URL
 */
const prepareURL = (type, date) => {
  try {
    let url = `https://www.tcmb.gov.tr/${
      type === "valid" ? "kurlar" : "bilgiamackur"
    }`;
    if (date) {
      if (!moment(date, "DD/MM/YYYY", true).isValid())
        throw new Error("Date format must be DD/MM/YYYY.");
      let momentDate = moment(date, "DD/MM/YYYY");
      if (momentDate.day() === 0) {
        // it's sunday, retrieve previous friday's rates.
        momentDate.subtract(2, "d");
      } else if (momentDate.day() === 6) {
        // it's saturday, retrieve previous friday's rates.
        momentDate.subtract(1, "d");
      }
      let dateStr = momentDate.format("DD/MM/YYYY").toString();
      let dateArray = dateStr.split("/");
      let day = dateArray[0];
      let month = dateArray[1];
      let year = dateArray[2];
      url += `/${year}${month}/${day}${month}${year}.xml`;
    } else {
      url += "/today.xml";
    }
    return url;
  } catch (error) {
    throw error;
  }
};

/**
 * Parses XML into JSON object.
 *
 * @param {*} xml
 * @return {*}
 */
const parseXML = (xml) => {
  return new Promise((resolve, reject) => {
    parseString(
      xml,
      {
        attrkey: "attributes",
        tagNameProcessors: [namePrettier],
        attrNameProcessors: [namePrettier],
        valueProcessors: [valueProcessors],
        trim: true,
        explicitArray: false,
        emptyTag: null,
      },
      (err, result) => {
        if (err) return reject(err);
        return resolve(result);
      }
    );
  });
};

/**
 * Conversion of JSON Object data according to provided currency.
 *
 * @param {*} data
 * @param {*} currency
 * @returns {*}
 */
const convertData = (data, currency) => {
  if (!data)
    return reject(new Error("Provided data to convert function is invalid."));
  let result = {
    date: _.replace(data.tarihDate.attributes.tarih, /\./g, "/"),
  };
  if (currency) {
    // return for currency
    let currencyObject = _.find(
      data.tarihDate.currency,
      (c) => c.attributes.currencyCode === currency
    );
    if (!currencyObject) return result;
    result.currency = currencyObject;
    return result;
  } else {
    // return all
    result.currencies = data.tarihDate.currency;
    return result;
  }
};

/**
 * Checks if the value is parsable to float. Returns float if it's.
 *
 * @param val
 * @returns float
 */
function valueProcessors(val) {
  if (val) {
    var floatVal = parseFloat(val);
    if (isNaN(floatVal)) return val;
    return floatVal;
  }
}

/**
 * Converts first letter of the given parameter to lowercase.
 *
 * @param string
 * @returns {string}
 */
function lowerCaseFirstLetter(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}

/**
 * Converts first letter of the given parameter to lowercase, then removes '_' and converts it to camel case.
 *
 * @param name
 * @returns {XML|string|void|*}
 */
function namePrettier(name) {
  return lowerCaseFirstLetter(name).replace(/[-_]+(.)?/g, function (g) {
    return g[1].toUpperCase();
  });
}
/**
 * Checks if provided day is a holiday. If it's, function recursively finds last valid
 * business day.
 *
 * @param {*} date DD/MM/YYYY
 * @param {*} maxRetries {int}
 * @returns response
 */
async function holidayCheck(type, date, maxRetries) {
  if (maxRetries == 0) {
    throw "No more retries";
  } else {
    try {
      var url = prepareURL(type, date);
      if (!url) new Error("Something went wrong while preparing request URL.");
      const response = await requestPromise(url);
      return response;
    } catch (error) {
      date = decreaseDay(date);
      return await holidayCheck(type, date, maxRetries - 1);
    }
  }
}

function requestPromise(url) {
  return new Promise((resolve, reject) => {
    const options = {
      url,
      method: "GET",
      headers: {
        "Content-Type": "application/xml",
      },
      strictSSL: false,
    };
    request(options, async (error, response, body) => {
      if (error || response.statusCode !== 200) {
        return reject(error);
      }
      return resolve(body);
    });
  });
}
